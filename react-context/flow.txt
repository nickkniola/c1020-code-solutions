Create a file in the root of your react-context solution directory named flow.txt. For each feature in the application, describe the flow of the code in writing, including the client, server, and database. How does it work?
User can sign up.
User can sign in.
User can stay signed in.

1.User can sign up.
The index.jsx file renders the app.jsx, which renders the AppContext.Provider enclosing the Navbar and PageContainer components. In the Navbar, there is a Sign Up anchor component, which when clicked, changes the hash of the url. In App.jsx, this.renderPage() is called , so then the path is 'sign-up', so it returns the Auth component, with the text to 'Create an account' and the component AuthForm with 'Register' text. Once the form is filled out and the submit button component is clicked, a fetch asynchronously occurs to the server with a particular action in the path. In the server, it takes the request at /api/auth/sign-up, checks that there is a username and password in the body, hashes the password, queries/inserts into the PostgreSQL database the username and hashed password, then returns a user object with a 201 status code. Back in auth-form.jsx, the .then() method takes the response and converts it from a data stream into JSON then into an JavaScript object, returning it to the next then() method, which makes sure the action is 'sign-up', so that the hash can now be 'sign-in' to go to the sign-in view, which renders.

2. The path is 'sign-in' in app.jsx, so it returns the Auth component, which has a path of 'sign-in' so the weclomeMessage says to sign in. The AuthForm component is rendered with passed props for key, action, onSignIn. Once that is rendered and the form is filled out and submit button is clicked, then the fetch POSt method is called with a url path with a action of 'sign-in' from props. On the server, in index.js, which is listening for requests, a post request to /api/auth/sign-in is received and it checks that the request has a username and password. Then, it makes a query to the SQL database to find the userId and hashedPassword from the users table with the specified username. Once there is a response, the result comes back and argon2 verifies that the hashedPassword and the password match, if they do, a token with payload is returned in a JSON object. The response stream is parsed as JSON and converted to a JavaScript object, then this.props.onSignIn(result) is called, which is really the handleSignIn in auth.jsx which comes from this.context, which is really handleSignIn in app.jsx. The token is set in localStorage and the user object is set in state. When navbar rerenders, user is no longer null so the Sign Out button appears, and sign-in/sign-up buttons are not rendered.

3. If the page reloads, since localStorage has the token stored under the key 'react-context-jwt', when the app.jsx mounts, the token is retrieved from localStorage, then state is set with user being the value of user and isAuthorizing being false, so that the render method returns the AppContent.Provider, Navbar, and PageContainer components. This.renderPage() is called  and the path is '', so it returns the Home component. In auth.jsx, it returns the Redirect component with a 'to' prop with a value of an empty url, so then in redirect.jsx, url.hash is '#'.